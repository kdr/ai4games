<!DOCTYPE html>
<!-- 
    FightR - Street Fighter Style Game
    
    IMPORTANT: The initGame function is now defined globally in main.js to ensure
    it's accessible from emergency handlers. This function properly initializes 
    the FightGame class and connects all UI elements.
    
    If the error "initGame function not found" persists:
    1. Make sure js/main.js is loaded properly
    2. Try pressing F3 to test the canvas
    3. Press F2 to force character creation
    4. Press F1 for a complete game reset
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fightr - Street Fighter Style Game</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Additional styles for AI info display */
        #ai-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 200px;
            display: none;
            z-index: 100;
        }
        
        .key-note {
            color: #ff3019;
            font-weight: bold;
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .victory-message {
            color: #ff3019;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            animation: pulse-text 1.5s infinite;
        }
        
        @keyframes pulse-text {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen" class="screen active">
            <h1>FIGHTR</h1>
            <button id="start-btn" onclick="showCharSelect()">START GAME</button>
        </div>

        <div id="character-select" class="screen">
            <h2>SELECT YOUR FIGHTER</h2>
            <div class="player-select">
                <div class="player-info">
                    <h3>PLAYER 1</h3>
                    <div id="p1-selection" class="selected-character">
                        <span class="character-name">Select a character</span>
                    </div>
                </div>
                <div class="player-info">
                    <h3>AI OPPONENT</h3>
                    <div id="p2-selection" class="selected-character">
                        <span class="character-name">AI will select...</span>
                    </div>
                </div>
            </div>
            <div class="character-grid">
                <div class="character" data-character="ninja">
                    <img src="assets/ninja_portrait.png" alt="Ninja">
                    <span>NINJA</span>
                </div>
                <div class="character" data-character="samurai">
                    <img src="assets/samurai_portrait.png" alt="Samurai">
                    <span>SAMURAI</span>
                </div>
                <div class="character" data-character="monk">
                    <img src="assets/monk_portrait.png" alt="Monk">
                    <span>MONK</span>
                </div>
                <div class="character" data-character="ronin">
                    <img src="assets/ronin_portrait.png" alt="Ronin">
                    <span>RONIN</span>
                </div>
            </div>
            <button id="fight-btn" disabled>FIGHT!</button>
            <div class="key-note">Press G (punch), H (kick), or J (special) to attack!</div>
        </div>

        <div id="battle-screen" class="screen">
            <div class="hud">
                <div class="player-hud" id="p1-hud">
                    <div class="player-name">PLAYER 1</div>
                    <div class="health-bar">
                        <div class="health-fill" id="p1-health"></div>
                    </div>
                </div>
                <div class="timer">90</div>
                <div class="player-hud" id="p2-hud">
                    <div class="player-name">AI OPPONENT</div>
                    <div class="health-bar">
                        <div class="health-fill" id="p2-health"></div>
                    </div>
                </div>
            </div>
            <canvas id="game-canvas" width="800" height="450"></canvas>
            
            <!-- AI Info Display -->
            <div id="ai-info">
                <div>AI STATUS</div>
                <div id="ai-state">Thinking...</div>
                <div id="ai-action">No action</div>
                <div id="ai-target">Distance: --</div>
            </div>
        </div>

        <div id="round-announcement" class="announcement">
            <div id="round-text">GET READY</div>
            <div id="fight-text">FIGHT!</div>
        </div>

        <div id="victory-screen" class="screen">
            <h2 id="winner-text">PLAYER 1 WINS!</h2>
            <div class="victory-message">Returning to character select...</div>
            <button id="rematch-btn" style="display:none;">REMATCH</button>
            <button id="character-select-btn">SELECT NEW FIGHTER</button>
        </div>
    </div>

    <div id="controls-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Controls</h2>
            <div class="controls-section">
                <h3>Player Controls</h3>
                <ul>
                    <li>W: Jump</li>
                    <li>A: Move Left</li>
                    <li>D: Move Right</li>
                    <li>S: Block</li>
                    <li>G: Punch</li>
                    <li>H: Kick</li>
                    <li>J: Special</li>
                </ul>
            </div>
            <div class="controls-section">
                <h3>AI Behavior</h3>
                <p>The AI opponent will intelligently:</p>
                <ul>
                    <li>Maintain optimal distance</li>
                    <li>Block incoming attacks</li>
                    <li>Strike when in range</li>
                    <li>Use special moves strategically</li>
                </ul>
            </div>
            <button id="close-controls">Close</button>
        </div>
    </div>

    <button id="controls-btn" class="controls-button">Controls</button>

    <!-- Emergency Error Display Overlay -->
    <div id="error-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; color: white; font-family: monospace; overflow: auto; padding: 20px; box-sizing: border-box;">
        <div style="max-width: 800px; margin: 0 auto; background: #300; padding: 20px; border-radius: 5px;">
            <h2 style="color: #f00; text-align: center;">GAME ERROR DETECTED</h2>
            <div id="error-message" style="color: #f66; margin-bottom: 15px; font-size: 16px; font-weight: bold;"></div>
            <div id="error-stack" style="color: #faa; margin-bottom: 20px; font-size: 14px; white-space: pre-wrap;"></div>
            <div id="error-context" style="color: #fff; margin-bottom: 20px; font-size: 14px;"></div>
            <div style="text-align: center;">
                <button onclick="document.getElementById('error-overlay').style.display='none';" style="background: #f33; color: white; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px;">Dismiss</button>
                <button onclick="window.location.reload();" style="background: #33f; color: white; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; margin-left: 10px;">Reload Page</button>
                <button onclick="resetGameEmergency();" style="background: #3c3; color: white; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; margin-left: 10px;">Emergency Reset</button>
            </div>
        </div>
    </div>

    <!-- Force retry loading game.js file if it failed initially -->
    <script>
        console.error("‚ö†Ô∏è Checking if game.js loaded properly...");
        if (typeof FightGame !== 'function') {
            console.error("üö® game.js did not load properly! Attempting to load it again...");
            const gameScript = document.createElement('script');
            gameScript.src = 'js/game.js?' + new Date().getTime(); // Add cache buster
            gameScript.onload = function() {
                console.error("‚úÖ game.js loaded successfully on second attempt!");
                if (typeof FightGame === 'function') {
                    console.error("FightGame class is now available");
                } else {
                    console.error("‚ùå Still cannot find FightGame class!");
                }
            };
            gameScript.onerror = function() {
                console.error("‚ùå Failed to load game.js on second attempt");
                alert("Critical error: Could not load game.js file. The emergency implementation will be used instead.");
            };
            document.body.appendChild(gameScript);
        } else {
            console.error("‚úÖ game.js loaded properly on first attempt");
        }
    </script>

    <script src="js/sprites.js"></script>
    <script src="js/characters.js"></script>
    <script src="js/game.js"></script>
    <script src="js/main.js"></script>
    <script>
        // Global emergency initialization code
        window.DEBUG = true;
        
        // Emergency factory function to create a game without relying on prototypes
        window.createEmergencyGame = function(canvas, useAI) {
            console.log("üö® Creating direct emergency game instance");
            
            // Create game object directly
            const game = {
                canvas: canvas,
                ctx: canvas.getContext('2d'),
                width: canvas.width,
                height: canvas.height,
                useAI: useAI || false,
                gameState: 'idle',
                leftBoundary: 100,
                rightBoundary: canvas.width - 100,
                groundY: canvas.height - 100,
                timeRemaining: 99,
                p1Wins: 0,
                p2Wins: 0,
                currentRound: 1,
                lastTime: 0,
                fpsInterval: 1000 / 60,
                keys: {
                    w: false, a: false, s: false, d: false,
                    g: false, h: false, j: false
                },
                player1: null,
                player2: null,
                // Add attack queue to manage attacks in order
                attackQueue: [],
                processingAttack: false,
                
                // All methods defined directly on the object
                setPlayers: function(char1, char2) {
                    console.log("Setting players:", char1, char2);
                    
                    // Create a simple character constructor
                    function createCharacter(options) {
                        return {
                            name: options.name || 'Unknown',
                            x: options.x || 100,
                            y: options.y || 350,
                            width: options.width || 80,
                            height: options.height || 150,
                            health: options.health || 100,
                            maxHealth: options.health || 100,
                            isFacingRight: options.isFacingRight !== false,
                            color: options.color || '#ff0000',
                            vx: 0,
                            vy: 0,
                            speed: options.speed || 5,
                            jumpPower: options.jumpPower || 15,
                            gravity: 0.8,
                            isGrounded: true,
                            isJumping: false,
                            isBlocking: false,
                            isAttacking: false,
                            attackType: null,
                            hasHit: false,
                            blockAnimation: false,
                            hurtTimeoutId: null,
                            attackTimeoutId: null,
                            
                            update: function() {
                                // Basic physics
                                if (!this.isGrounded) {
                                    this.vy += this.gravity;
                                }
                                
                                // Update position
                                this.x += this.vx;
                                this.y += this.vy;
                                
                                // Ground collision
                                if (this.y > 350) {
                                    this.y = 350;
                                    this.vy = 0;
                                    this.isGrounded = true;
                                    this.isJumping = false;
                                }
                                
                                return true;
                            },
                            
                            draw: function(ctx) {
                                ctx.fillStyle = this.color;
                                ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                                
                                // Draw name
                                ctx.fillStyle = 'white';
                                ctx.font = '16px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText(this.name, this.x, this.y - this.height - 10);
                                
                                // Draw if blocking
                                if (this.isBlocking) {
                                    const blockOpacity = this.blockAnimation ? 0.8 : 0.5;
                                    ctx.fillStyle = `rgba(255, 255, 0, ${blockOpacity})`;
                                    ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                                    
                                    if (this.blockAnimation) {
                                        ctx.fillStyle = 'white';
                                        ctx.font = '20px Arial';
                                        ctx.fillText('BLOCK!', this.x, this.y - this.height/2);
                                    }
                                }
                                
                                // Draw if attacking
                                if (this.isAttacking) {
                                    const attackTexts = {
                                        'punch': 'üëä',
                                        'kick': 'ü¶∂',
                                        'special': '‚ö°Ô∏è'
                                    };
                                    
                                    ctx.font = '24px Arial';
                                    const attackX = this.isFacingRight ? this.x + this.width/2 + 20 : this.x - this.width/2 - 20;
                                    ctx.fillText(attackTexts[this.attackType] || '!', attackX, this.y - this.height/2);
                                }
                            },
                            
                            punch: function() {
                                if (this.isAttacking) return false; // Prevent attack spamming
                                this.isAttacking = true;
                                this.attackType = 'punch';
                                console.log(`${this.name} punches!`);
                                
                                // Clear any existing attack timeout
                                if (this.attackTimeoutId) clearTimeout(this.attackTimeoutId);
                                
                                // Reset attack state after drawing
                                const self = this;
                                this.attackTimeoutId = setTimeout(() => {
                                    self.isAttacking = false;
                                    self.attackType = null;
                                    self.attackTimeoutId = null;
                                }, 300);
                                
                                return true;
                            },
                            
                            kick: function() {
                                if (this.isAttacking) return false; // Prevent attack spamming
                                this.isAttacking = true;
                                this.attackType = 'kick';
                                console.log(`${this.name} kicks!`);
                                
                                // Clear any existing attack timeout
                                if (this.attackTimeoutId) clearTimeout(this.attackTimeoutId);
                                
                                // Reset attack state after drawing
                                const self = this;
                                this.attackTimeoutId = setTimeout(() => {
                                    self.isAttacking = false;
                                    self.attackType = null;
                                    self.attackTimeoutId = null;
                                }, 300);
                                
                                return true;
                            },
                            
                            special: function() {
                                if (this.isAttacking) return false; // Prevent attack spamming
                                this.isAttacking = true;
                                this.attackType = 'special';
                                console.log(`${this.name} uses special attack!`);
                                
                                // Clear any existing attack timeout
                                if (this.attackTimeoutId) clearTimeout(this.attackTimeoutId);
                                
                                // Reset attack state after drawing
                                const self = this;
                                this.attackTimeoutId = setTimeout(() => {
                                    self.isAttacking = false;
                                    self.attackType = null;
                                    self.attackTimeoutId = null;
                                }, 300);
                                
                                return true;
                            },
                            
                            takeDamage: function(amount) {
                                // Clear any existing hurt timeout
                                if (this.hurtTimeoutId) {
                                    clearTimeout(this.hurtTimeoutId);
                                    this.hurtTimeoutId = null;
                                }
                                
                                if (this.isBlocking) {
                                    amount = Math.floor(amount / 3);
                                    console.log(`Blocked! Reduced damage to ${amount}`);
                                    this.blockAnimation = true;
                                    const self = this;
                                    setTimeout(() => {
                                        self.blockAnimation = false;
                                    }, 300);
                                }
                                
                                // Ensure amount is positive and health never increases
                                amount = Math.abs(amount);
                                
                                // Subtract damage from health
                                const oldHealth = this.health;
                                this.health = Math.max(0, Math.min(this.health - amount, this.maxHealth));
                                
                                console.log(`${this.name} health: ${oldHealth} -> ${this.health}/${this.maxHealth}, damage: ${amount}`);
                                return true;
                            },
                            
                            moveLeft: function() { this.vx = -this.speed; this.isFacingRight = false; },
                            moveRight: function() { this.vx = this.speed; this.isFacingRight = true; },
                            stopMoving: function() { this.vx = 0; },
                            jump: function() {
                                if (this.isGrounded) {
                                    this.vy = -this.jumpPower;
                                    this.isGrounded = false;
                                    this.isJumping = true;
                                }
                            },
                            
                            startBlock: function() { this.isBlocking = true; },
                            endBlock: function() { this.isBlocking = false; },
                            
                            getCurrentHitbox: function() {
                                if (!this.isAttacking) return null;
                                
                                const hitboxWidth = this.attackType === 'punch' ? 60 :
                                                   this.attackType === 'kick' ? 70 : 80;
                                
                                const hitboxX = this.isFacingRight ?
                                    this.x + this.width/2 :
                                    this.x - this.width/2 - hitboxWidth;
                                    
                                return {
                                    x: hitboxX,
                                    y: this.y - this.height/2,
                                    width: hitboxWidth,
                                    height: 40,
                                    damage: this.attackType === 'punch' ? 5 :
                                            this.attackType === 'kick' ? 8 : 15
                                };
                            }
                        };
                    }
                    
                    // Create player1
                    this.player1 = createCharacter({
                        name: char1,
                        x: 200,
                        y: this.groundY,
                        isFacingRight: true,
                        color: '#0066cc',
                        speed: 5,
                        jumpPower: 15,
                        health: 100
                    });
                    
                    // Create player2
                    this.player2 = createCharacter({
                        name: char2,
                        x: 600,
                        y: this.groundY,
                        isFacingRight: false,
                        color: '#cc3300',
                        speed: 5,
                        jumpPower: 15,
                        health: 100
                    });
                    
                    console.log("Emergency players created successfully");
                    return true;
                },
                
                // New method to process attacks one at a time
                processAttackQueue: function() {
                    if (this.processingAttack || this.attackQueue.length === 0) return;
                    
                    this.processingAttack = true;
                    const attack = this.attackQueue.shift();
                    
                    console.log(`Processing attack: ${attack.attacker.name} -> ${attack.target.name} (${attack.damage})`);
                    attack.target.takeDamage(attack.damage);
                    this.updateHealthDisplay();
                    
                    // Give a delay between processing attacks
                    const self = this;
                    setTimeout(() => {
                        self.processingAttack = false;
                        self.processAttackQueue();
                    }, 100);
                },
                
                // Add attack to queue instead of applying it immediately
                addAttackToQueue: function(attacker, target, damage, type) {
                    this.attackQueue.push({
                        attacker: attacker,
                        target: target,
                        damage: damage,
                        type: type
                    });
                    
                    this.processAttackQueue();
                },
                
                connect: function(elements) {
                    console.log("Connecting UI elements:", elements);
                    this.healthBarP1 = elements.healthP1;
                    this.healthBarP2 = elements.healthP2;
                    this.timerElement = elements.timer;
                    this.announcementElement = elements.announcement;
                    this.roundTextElement = elements.roundText;
                    this.fightTextElement = elements.fightText;
                    return true;
                },
                
                start: function() {
                    console.log("Starting emergency game");
                    this.gameState = 'starting';
                    
                    // Reset game state
                    this.timeRemaining = 99;
                    this.currentRound = 1;
                    this.p1Wins = 0;
                    this.p2Wins = 0;
                    
                    // Reset the announcement elements to make sure they're hidden
                    if (this.announcementElement) {
                        this.announcementElement.style.display = 'none';
                    }
                    
                    if (this.roundTextElement) {
                        this.roundTextElement.style.display = 'none';
                    }
                    
                    if (this.fightTextElement) {
                        this.fightTextElement.style.display = 'none';
                    }
                    
                    // Update timer display
                    if (this.timerElement) {
                        this.timerElement.textContent = this.timeRemaining;
                    }
                    
                    // Setup keyboard input
                    this.setupEventListeners();
                    
                    // Start round
                    this.startRound();
                    
                    // Start game loop
                    const self = this;
                    this.animationFrameId = requestAnimationFrame(function(time) {
                        self.gameLoop(time);
                    });
                    
                    return true;
                },
                
                startRound: function() {
                    console.log("Starting round", this.currentRound);
                    this.gameState = 'starting';
                    
                    // Clear attack queue
                    this.attackQueue = [];
                    this.processingAttack = false;
                    
                    // Reset player positions
                    if (this.player1) {
                        this.player1.x = 200;
                        this.player1.health = 100; // Always start with exact health value
                        this.player1.maxHealth = 100;
                        this.player1.hasHit = false;
                        if (this.player1.attackTimeoutId) clearTimeout(this.player1.attackTimeoutId);
                        if (this.player1.hurtTimeoutId) clearTimeout(this.player1.hurtTimeoutId);
                    }
                    
                    if (this.player2) {
                        this.player2.x = 600;
                        this.player2.health = 100; // Always start with exact health value
                        this.player2.maxHealth = 100;
                        this.player2.hasHit = false;
                        if (this.player2.attackTimeoutId) clearTimeout(this.player2.attackTimeoutId);
                        if (this.player2.hurtTimeoutId) clearTimeout(this.player2.hurtTimeoutId);
                    }
                    
                    // Update health display
                    this.updateHealthDisplay();
                    
                    // Show round announcement
                    this.showRoundAnnouncement();
                    
                    // Start timer
                    this.startTimer();
                },
                
                updateHealthDisplay: function() {
                    if (!this.player1 || !this.player2) return false;
                    
                    // Calculate health percentages
                    const p1HealthPercent = (this.player1.health / this.player1.maxHealth) * 100;
                    const p2HealthPercent = (this.player2.health / this.player2.maxHealth) * 100;
                    
                    // Update health bar for player 1
                    if (this.healthBarP1) {
                        this.healthBarP1.style.width = `${p1HealthPercent}%`;
                    }
                    
                    // Update health bar for player 2
                    if (this.healthBarP2) {
                        this.healthBarP2.style.width = `${p2HealthPercent}%`;
                    }
                    
                    return true;
                },
                
                setupEventListeners: function() {
                    const self = this;
                    
                    // Add key handlers
                    window.addEventListener('keydown', function(e) {
                        // Update key state
                        if (e.key.toLowerCase() in self.keys) {
                            self.keys[e.key.toLowerCase()] = true;
                        }
                    });
                    
                    window.addEventListener('keyup', function(e) {
                        // Update key state
                        if (e.key.toLowerCase() in self.keys) {
                            self.keys[e.key.toLowerCase()] = false;
                        }
                    });
                },
                
                handleInput: function() {
                    if (this.gameState !== 'fighting') return;
                    
                    // Handle player 1 movement
                    if (this.player1) {
                        // Handle movement
                        if (this.keys.a) {
                            this.player1.moveLeft();
                        } else if (this.keys.d) {
                            this.player1.moveRight();
                        } else {
                            this.player1.stopMoving();
                        }
                        
                        // Handle jumping
                        if (this.keys.w && !this.player1.isJumping && this.player1.isGrounded) {
                            this.player1.jump();
                        }
                        
                        // Handle blocking
                        if (this.keys.s) {
                            this.player1.startBlock();
                        } else {
                            this.player1.endBlock();
                        }
                        
                        // Handle attacks
                        if (this.keys.g) {
                            this.player1.punch();
                            this.keys.g = false; // Prevent holding down
                        }
                        
                        if (this.keys.h) {
                            this.player1.kick();
                            this.keys.h = false; // Prevent holding down
                        }
                        
                        if (this.keys.j) {
                            this.player1.special();
                            this.keys.j = false; // Prevent holding down
                        }
                    }
                },
                
                handleAI: function() {
                    if (this.gameState !== 'fighting' || !this.useAI || !this.player2) return;
                    
                    // Basic AI: move toward player1 and randomly attack
                    if (Math.random() < 0.01) { // Reduced from 0.02 to 0.01 (1% chance to jump)
                        this.player2.jump();
                    }
                    
                    // Don't attack if already attacking
                    if (this.player2.isAttacking) {
                        // Stop moving when attacking
                        this.player2.stopMoving();
                        return;
                    }
                    
                    // If has hit, don't allow more attacks for a moment
                    if (this.player2.hasHit) return;
                    
                    // Move toward player
                    if (this.player2.x > this.player1.x + 100) {
                        this.player2.moveLeft();
                    } else if (this.player2.x < this.player1.x - 100) {
                        this.player2.moveRight();
                    } else {
                        // In attack range - reduce attack frequency
                        const attackChance = Math.random();
                        
                        if (attackChance < 0.005) { // Reduced from 0.01 to 0.005 (0.5% chance for special)
                            this.player2.special();
                        } else if (attackChance < 0.015) { // Reduced from 0.03 to 0.015 (1% chance for kick)
                            this.player2.kick();
                        } else if (attackChance < 0.03) { // Reduced from 0.06 to 0.03 (1.5% chance for punch)
                            this.player2.punch();
                        } else if (attackChance < 0.05) { // Reduced from 0.08 to 0.05 (2% chance to block)
                            this.player2.startBlock();
                        } else {
                            this.player2.endBlock();
                            this.player2.stopMoving();
                        }
                    }
                },
                
                update: function() {
                    if (this.gameState !== 'fighting') return;
                    
                    // Update players
                    if (this.player1) this.player1.update();
                    if (this.player2) this.player2.update();
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Check for KO
                    if (this.player1.health <= 0) {
                        console.log("Player 2 (AI) wins!");
                        this.endRound(2);
                    } else if (this.player2.health <= 0) {
                        console.log("Player 1 wins!");
                        this.endRound(1);
                    }
                },
                
                checkCollisions: function() {
                    if (!this.player1 || !this.player2) return;
                    
                    // Check for attack hitboxes
                    const p1Hitbox = this.player1.getCurrentHitbox();
                    const p2Hitbox = this.player2.getCurrentHitbox();
                    
                    // Player bounds
                    const p1Bounds = {
                        x: this.player1.x - this.player1.width/2,
                        y: this.player1.y - this.player1.height,
                        width: this.player1.width,
                        height: this.player1.height
                    };
                    
                    const p2Bounds = {
                        x: this.player2.x - this.player2.width/2,
                        y: this.player2.y - this.player2.height,
                        width: this.player2.width,
                        height: this.player2.height
                    };
                    
                    // Check if Player 1's attack hits Player 2
                    if (p1Hitbox && this.checkOverlap(p1Hitbox, p2Bounds) && !this.player1.hasHit) {
                        console.log(`P1 ${this.player1.attackType} hit P2!`);
                        this.player1.hasHit = true;
                        
                        // Add attack to queue instead of applying damage immediately
                        this.addAttackToQueue(this.player1, this.player2, p1Hitbox.damage, this.player1.attackType);
                        
                        // Adding a longer cooldown to prevent multiple hits
                        setTimeout(() => {
                            this.player1.hasHit = false;
                        }, 800); // Increased from 500 to 800ms
                    }
                    
                    // Check if Player 2's attack hits Player 1
                    if (p2Hitbox && this.checkOverlap(p2Hitbox, p1Bounds) && !this.player2.hasHit) {
                        console.log(`P2 ${this.player2.attackType} hit P1!`);
                        this.player2.hasHit = true;
                        
                        // Add attack to queue instead of applying damage immediately
                        this.addAttackToQueue(this.player2, this.player1, p2Hitbox.damage, this.player2.attackType);
                        
                        // Adding a longer cooldown to prevent multiple hits
                        setTimeout(() => {
                            this.player2.hasHit = false;
                        }, 800); // Increased from 500 to 800ms
                    }
                },
                
                checkOverlap: function(rect1, rect2) {
                    return (
                        rect1.x < rect2.x + rect2.width &&
                        rect1.x + rect1.width > rect2.x &&
                        rect1.y < rect2.y + rect2.height &&
                        rect1.y + rect1.height > rect2.y
                    );
                },
                
                showRoundAnnouncement: function() {
                    console.log(`Showing round ${this.currentRound} announcement`);
                    
                    if (this.announcementElement) {
                        this.announcementElement.style.display = 'flex';
                    }
                    
                    if (this.roundTextElement) {
                        this.roundTextElement.textContent = `ROUND ${this.currentRound}`;
                        this.roundTextElement.style.display = 'block';
                    }
                    
                    const self = this;
                    // Show fight text after delay
                    setTimeout(function() {
                        if (self.roundTextElement) {
                            self.roundTextElement.style.display = 'none';
                        }
                        
                        if (self.fightTextElement) {
                            self.fightTextElement.style.display = 'block';
                        }
                        
                        // Hide announcement after delay
                        setTimeout(function() {
                            if (self.announcementElement) {
                                self.announcementElement.style.display = 'none';
                            }
                            
                            if (self.fightTextElement) {
                                self.fightTextElement.style.display = 'none';
                            }
                            
                            // Change game state to fighting
                            self.gameState = 'fighting';
                        }, 1000);
                    }, 2000);
                },
                
                startTimer: function() {
                    console.log("Starting timer");
                    
                    // Clear any existing timer
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                    
                    // Set initial time and update display
                    this.timeRemaining = 99;
                    
                    if (this.timerElement) {
                        this.timerElement.textContent = this.timeRemaining;
                    }
                    
                    const self = this;
                    // Start timer countdown
                    this.timerInterval = setInterval(function() {
                        self.timeRemaining--;
                        
                        if (self.timerElement) {
                            self.timerElement.textContent = self.timeRemaining;
                        }
                        
                        if (self.timeRemaining <= 0) {
                            clearInterval(self.timerInterval);
                            self.endRound(0); // Time up
                        }
                    }, 1000);
                },
                
                endRound: function(winner) {
                    console.log("Ending round with winner:", winner);
                    
                    // Prevent multiple calls to endRound
                    if (this.gameState === 'roundEnd') {
                        return;
                    }
                    
                    this.gameState = 'roundEnd';
                    
                    // Update win counters
                    if (winner === 1) {
                        this.p1Wins++;
                    } else if (winner === 2) {
                        this.p2Wins++;
                    } else {
                        // Time up - determine winner by health
                        if (this.player1.health > this.player2.health) {
                            this.p1Wins++;
                            winner = 1;
                        } else if (this.player2.health > this.player1.health) {
                            this.p2Wins++;
                            winner = 2;
                        } else {
                            // Draw - player 1 wins by default
                            this.p1Wins++;
                            winner = 1;
                        }
                    }
                    
                    // Display the round winner
                    if (this.announcementElement) {
                        this.announcementElement.style.display = 'flex';
                    }
                    
                    if (this.roundTextElement) {
                        this.roundTextElement.textContent = winner === 1 ? 'PLAYER 1 WINS!' : 'AI WINS!';
                        this.roundTextElement.style.display = 'block';
                    }
                    
                    const self = this;
                    // Check if match is over (2 wins)
                    if (this.p1Wins >= 2 || this.p2Wins >= 2) {
                        // Match over - announce the final winner
                        const finalWinner = this.p1Wins >= 2 ? 'PLAYER 1' : 'AI';
                        console.log(`Match over! ${finalWinner} wins!`);
                        
                        if (this.roundTextElement) {
                            this.roundTextElement.textContent = `${finalWinner} WINS THE MATCH!`;
                        }
                        
                        // Return to character select after delay
                        setTimeout(function() {
                            // Stop the game
                            self.stop();
                            
                            // Make sure to cancel all active timeouts
                            const highestId = window.setTimeout(() => {}, 0);
                            for (let i = highestId; i >= 0; i--) {
                                window.clearTimeout(i); 
                            }
                            
                            // Explicitly hide the announcement elements
                            if (self.announcementElement) {
                                self.announcementElement.style.display = 'none';
                            }
                            
                            if (self.roundTextElement) {
                                self.roundTextElement.style.display = 'none';
                            }
                            
                            if (self.fightTextElement) {
                                self.fightTextElement.style.display = 'none';
                            }
                            
                            // Forcibly hide battle screen and show character select
                            document.querySelectorAll('.screen').forEach(s => {
                                s.classList.remove('active');
                                s.style.display = 'none';
                            });
                            
                            const charSelect = document.getElementById('character-select');
                            if (charSelect) {
                                charSelect.classList.add('active');
                                charSelect.style.display = 'flex';
                            }
                            
                            // Reset fight button
                            const fightBtn = document.getElementById('fight-btn');
                            if (fightBtn) {
                                fightBtn.disabled = true;
                            }
                            
                            // Clear character selections
                            document.querySelectorAll('.character').forEach(el => {
                                el.classList.remove('selected');
                            });
                            
                            const p1Selection = document.getElementById('p1-selection');
                            if (p1Selection) {
                                p1Selection.innerHTML = '<span class="character-name">Select a character</span>';
                            }
                            
                            const p2Selection = document.getElementById('p2-selection');
                            if (p2Selection) {
                                p2Selection.innerHTML = '<span class="character-name">AI will select...</span>';
                            }
                            
                            console.log("Returned to character select screen");
                        }, 3000);
                    } else {
                        // Start next round after delay
                        setTimeout(function() {
                            // Hide announcement
                            if (self.announcementElement) {
                                self.announcementElement.style.display = 'none';
                            }
                            
                            if (self.roundTextElement) {
                                self.roundTextElement.style.display = 'none';
                            }
                            
                            // Start next round
                            self.currentRound++;
                            self.startRound();
                        }, 3000);
                    }
                },
                
                draw: function() {
                    // Clear the canvas
                    this.ctx.clearRect(0, 0, this.width, this.height);
                    
                    // Try to use cached background if available
                    if (window.emergencyAssets && window.emergencyAssets['dojo_bg.png']) {
                        const bgImg = new Image();
                        bgImg.src = window.emergencyAssets['dojo_bg.png'];
                        
                        if (bgImg.complete) {
                            this.ctx.drawImage(bgImg, 0, 0, this.width, this.height);
                        } else {
                            // Fallback to gradient
                            const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                            gradient.addColorStop(0, '#331800');
                            gradient.addColorStop(0.7, '#663300');
                            gradient.addColorStop(1, '#331800');
                            
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(0, 0, this.width, this.height);
                        }
                    } else {
                        // Draw background from asset or use gradient if not available
                        const bgImage = new Image();
                        bgImage.src = 'assets/dojo_bg.png';
                        
                        if (bgImage.complete) {
                            this.ctx.drawImage(bgImage, 0, 0, this.width, this.height);
                        } else {
                            // Use gradient background
                            const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                            gradient.addColorStop(0, '#331800');
                            gradient.addColorStop(0.7, '#663300');
                            gradient.addColorStop(1, '#331800');
                            
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(0, 0, this.width, this.height);
                            
                            // Try to create placeholder for next time
                            if (typeof createPlaceholder === 'function') {
                                createPlaceholder('dojo_bg.png', 800, 450, '#331800');
                            }
                        }
                    }
                    
                    // Draw ground
                    this.ctx.fillStyle = '#221100';
                    this.ctx.fillRect(0, this.groundY, this.width, this.height - this.groundY);
                    
                    // Draw players
                    if (this.player1) this.player1.draw(this.ctx);
                    if (this.player2) this.player2.draw(this.ctx);
                    
                    // Draw hitboxes for debugging if in debug mode
                    if (window.DEBUG) {
                        // Draw player 1 hitbox
                        const p1Hitbox = this.player1?.getCurrentHitbox();
                        if (p1Hitbox) {
                            this.ctx.strokeStyle = 'yellow';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(p1Hitbox.x, p1Hitbox.y, p1Hitbox.width, p1Hitbox.height);
                        }
                        
                        // Draw player 2 hitbox
                        const p2Hitbox = this.player2?.getCurrentHitbox();
                        if (p2Hitbox) {
                            this.ctx.strokeStyle = 'cyan';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(p2Hitbox.x, p2Hitbox.y, p2Hitbox.width, p2Hitbox.height);
                        }
                        
                        // Draw player bounds
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 1;
                        if (this.player1) {
                            this.ctx.strokeRect(
                                this.player1.x - this.player1.width/2,
                                this.player1.y - this.player1.height,
                                this.player1.width,
                                this.player1.height
                            );
                        }
                        
                        if (this.player2) {
                            this.ctx.strokeRect(
                                this.player2.x - this.player2.width/2,
                                this.player2.y - this.player2.height,
                                this.player2.width,
                                this.player2.height
                            );
                        }
                    }
                },
                
                gameLoop: function(currentTime) {
                    const self = this;
                    // Request the next frame
                    this.animationFrameId = requestAnimationFrame(function(time) {
                        self.gameLoop(time);
                    });
                    
                    // Calculate elapsed time
                    const elapsed = currentTime - this.lastTime;
                    
                    // Only update if enough time has passed
                    if (elapsed > this.fpsInterval) {
                        // Update last time
                        this.lastTime = currentTime - (elapsed % this.fpsInterval);
                        
                        // Handle input
                        this.handleInput();
                        
                        // Handle AI
                        if (this.useAI) {
                            this.handleAI();
                        }
                        
                        // Update game state
                        this.update();
                        
                        // Draw the current frame
                        this.draw();
                    }
                },
                
                stop: function() {
                    console.log("Stopping game");
                    
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                    
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                    
                    // Clear all pending attacks
                    this.attackQueue = [];
                    this.processingAttack = false;
                    
                    // Clear any character timeouts
                    if (this.player1) {
                        if (this.player1.attackTimeoutId) clearTimeout(this.player1.attackTimeoutId);
                        if (this.player1.hurtTimeoutId) clearTimeout(this.player1.hurtTimeoutId);
                    }
                    
                    if (this.player2) {
                        if (this.player2.attackTimeoutId) clearTimeout(this.player2.attackTimeoutId);
                        if (this.player2.hurtTimeoutId) clearTimeout(this.player2.hurtTimeoutId);
                    }
                    
                    this.gameState = 'idle';
                }
            };
            
            console.log("Emergency game instance created successfully");
            return game;
        };
        
        // Ensure FightGame exists - use our emergency implementation if needed
        if (typeof FightGame !== 'function') {
            console.error("üö® FightGame class not found - Using emergency factory function");
            window.FightGame = function(canvas, useAI) {
                return window.createEmergencyGame(canvas, useAI);
            };
        }
        
        // Ensure window.initGame exists and works with our emergency implementation
        if (typeof window.initGame !== 'function') {
            console.error("üö® initGame function not found - Creating direct emergency implementation");
            
            window.initGame = function() {
                console.log("Direct emergency initGame function called");
                
                try {
                    // Get the canvas element
                    const canvas = document.getElementById('game-canvas');
                    if (!canvas) {
                        console.error("‚ùå Game canvas not found");
                        return null;
                    }
                    
                    // Create fight game instance - use emergency implementation
                    const game = window.createEmergencyGame(canvas, true);
                    
                    // Connect UI elements
                    game.connect({
                        healthP1: document.getElementById('p1-health'),
                        healthP2: document.getElementById('p2-health'),
                        timer: document.querySelector('.timer'),
                        announcement: document.getElementById('round-announcement'),
                        roundText: document.getElementById('round-text'),
                        fightText: document.getElementById('fight-text')
                    });
                    
                    console.log("‚úÖ Emergency game initialization successful");
                    
                    // Save as global reference
                    window.game = game;
                    
                    return game;
                } catch (e) {
                    console.error("‚ùå Error in emergency initGame:", e);
                    
                    // Show error message
                    const canvas = document.getElementById('game-canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = 'red';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'white';
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ERROR: Game init failed', canvas.width/2, canvas.height/2 - 50);
                        ctx.fillText(e.message, canvas.width/2, canvas.height/2);
                        ctx.fillText('Press F2 to try character creation', canvas.width/2, canvas.height/2 + 50);
                        ctx.fillText('Press F3 to test canvas', canvas.width/2, canvas.height/2 + 100);
                    }
                    
                    return null;
                }
            };
            
            console.log("Emergency initGame function created successfully");
        }
        
        // Function to show character selection
        function showCharSelect() {
            document.getElementById('title-screen').classList.remove('active');
            document.getElementById('character-select').classList.add('active');
            
            // Pre-generate background immediately on character select
            createPlaceholderIfMissing('dojo_bg.png', 800, 450, '#331800');
        }
        
        // Expose showCharSelect globally
        window.showCharSelect = showCharSelect;
        
        // Load handlers for character selection
        document.addEventListener('DOMContentLoaded', function() {
            // Create dojo background if missing
            createPlaceholderIfMissing('dojo_bg.png', 800, 450, '#003366');
            
            // Add direct character selection
            document.querySelectorAll('.character').forEach(characterElement => {
                characterElement.onclick = function() {
                    console.log("Direct character click detected:", this.getAttribute('data-character'));
                    
                    // Clear previous selections
                    document.querySelectorAll('.character').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Mark this character as selected
                    this.classList.add('selected');
                    
                    // Get character data
                    const character = this.getAttribute('data-character');
                    
                    // Create a global reference to access from other scripts
                    window.p1Character = character;
                    
                    // Update player 1 selection display
                    const p1Selection = document.getElementById('p1-selection');
                    if (p1Selection) {
                        // Create a portrait if missing
                        createPlaceholderIfMissing(`${character}_portrait.png`, 80, 80, getCharColor(character));
                        
                        p1Selection.innerHTML = `
                            <img src="assets/${character}_portrait.png" alt="${character}">
                            <span class="character-name">${getCharName(character)}</span>
                        `;
                    }
                    
                    // Randomly select AI character
                    const availableChars = ['ninja', 'samurai', 'monk', 'ronin'].filter(c => c !== character);
                    const p2Character = availableChars[Math.floor(Math.random() * availableChars.length)];
                    
                    // Store for global access
                    window.p2Character = p2Character;
                    
                    // Update AI selection display
                    const p2Selection = document.getElementById('p2-selection');
                    if (p2Selection) {
                        // Create a portrait if missing
                        createPlaceholderIfMissing(`${p2Character}_portrait.png`, 80, 80, getCharColor(p2Character));
                        
                        p2Selection.innerHTML = `
                            <img src="assets/${p2Character}_portrait.png" alt="${p2Character}">
                            <span class="character-name">${getCharName(p2Character)}</span>
                        `;
                    }
                    
                    // Highlight AI selection after delay
                    setTimeout(() => {
                        const aiChar = document.querySelector(`.character[data-character="${p2Character}"]`);
                        if (aiChar) aiChar.classList.add('selected');
                        
                        // Enable fight button
                        const fightBtn = document.getElementById('fight-btn');
                        if (fightBtn) fightBtn.disabled = false;
                    }, 1000);
                };
            });
            
            // Add direct fight button handler
            document.getElementById('fight-btn')?.addEventListener('click', function() {
                console.log("Direct fight button click");
                document.querySelectorAll('.screen').forEach(s => {
                    s.style.display = 'none';
                    s.classList.remove('active');
                });
                
                const battleScreen = document.getElementById('battle-screen');
                if (battleScreen) {
                    battleScreen.style.display = 'flex';
                    battleScreen.classList.add('active');
                }
                
                // Initialize the game if it exists
                if (typeof initGame === 'function') {
                    const game = initGame();
                    if (game && window.p1Character && window.p2Character) {
                        game.setPlayers(window.p1Character, window.p2Character);
                        game.start();
                    }
                }
            });
            
            // Add event listener for character-select button on victory screen
            document.getElementById('character-select-btn')?.addEventListener('click', function() {
                console.log("Character select button clicked");
                if (window.game && typeof window.game.returnToCharSelect === 'function') {
                    window.game.returnToCharSelect();
                } else {
                    // Fallback if game object doesn't exist
                    document.querySelectorAll('.screen').forEach(s => {
                        s.classList.remove('active');
                        s.style.display = 'none';
                    });
                    
                    const charSelect = document.getElementById('character-select');
                    if (charSelect) {
                        charSelect.classList.add('active');
                        charSelect.style.display = 'flex';
                    }
                }
            });
        });
        
        // Helper functions for character data and placeholders
        function getCharName(character) {
            const names = {
                ninja: 'Ninja',
                samurai: 'Samurai',
                monk: 'Monk',
                ronin: 'Ronin'
            };
            return names[character] || character.charAt(0).toUpperCase() + character.slice(1);
        }
        
        function getCharColor(character) {
            const colors = {
                ninja: '#4299e1',   // Blue
                samurai: '#e53e3e', // Red
                monk: '#ecc94b',    // Yellow
                ronin: '#48bb78'    // Green
            };
            return colors[character] || '#888888';
        }
        
        function createPlaceholderIfMissing(filename, width, height, color) {
            // Create a test image to see if the file exists
            const testImg = new Image();
            testImg.onerror = function() {
                console.log(`Creating placeholder for missing asset: ${filename}`);
                createPlaceholder(filename, width, height, color);
            };
            testImg.src = `assets/${filename}`;
            
            // Force pre-create placeholder after a short timeout
            // This ensures we have a placeholder even if the image load is delayed
            setTimeout(function() {
                if (!testImg.complete || testImg.naturalWidth === 0) {
                    console.log(`Pre-creating placeholder for: ${filename}`);
                    createPlaceholder(filename, width, height, color);
                }
            }, 100);
        }
        
        function createPlaceholder(filename, width, height, color) {
            // Create canvas element
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            // Get drawing context
            const ctx = canvas.getContext('2d');
            
            // Draw background
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, width, height);
            
            // For background, add some simple design
            if (filename === 'dojo_bg.png') {
                // Draw dojo floor
                ctx.fillStyle = '#221100';
                ctx.fillRect(0, height - 100, width, 100);
                
                // Draw some background elements
                ctx.fillStyle = '#552200';
                ctx.fillRect(50, 50, 100, 300);
                ctx.fillRect(650, 50, 100, 300);
                
                // Add some texture
                ctx.strokeStyle = '#662200';
                ctx.lineWidth = 3;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * 45);
                    ctx.lineTo(width, i * 45);
                    ctx.stroke();
                }
            } else {
                // Add text label for other images
                ctx.fillStyle = 'white';
                ctx.font = `${Math.min(width, height) / 8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(filename, width / 2, height / 2);
            }
            
            // Convert to data URL
            const dataUrl = canvas.toDataURL('image/png');
            
            // Store in gameAssets if available
            if (window.gameAssets) {
                window.gameAssets[filename] = dataUrl;
            }
            
            // Create a global cache of assets
            if (!window.emergencyAssets) {
                window.emergencyAssets = {};
            }
            window.emergencyAssets[filename] = dataUrl;
            
            // Preload the image
            const img = new Image();
            img.src = dataUrl;
            
            // Replace all existing img elements with this src
            document.querySelectorAll(`img[src="assets/${filename}"]`).forEach(imgEl => {
                imgEl.src = dataUrl;
            });
            
            return dataUrl;
        }

        // Initialize emergency assets immediately
        document.addEventListener('DOMContentLoaded', function() {
            // Preload key assets
            createPlaceholderIfMissing('dojo_bg.png', 800, 450, '#331800');
            createPlaceholderIfMissing('ninja_portrait.png', 80, 80, getCharColor('ninja'));
            createPlaceholderIfMissing('samurai_portrait.png', 80, 80, getCharColor('samurai'));
            createPlaceholderIfMissing('monk_portrait.png', 80, 80, getCharColor('monk'));
            createPlaceholderIfMissing('ronin_portrait.png', 80, 80, getCharColor('ronin'));
            
            console.log("Emergency assets preloaded");
            
            // Setup controls button handler
            const controlsBtn = document.getElementById('controls-btn');
            const controlsOverlay = document.getElementById('controls-overlay');
            const closeControlsBtn = document.getElementById('close-controls');
            
            if (controlsBtn && controlsOverlay) {
                controlsBtn.addEventListener('click', function() {
                    console.log("Controls button clicked");
                    controlsOverlay.style.display = 'flex';
                });
                
                if (closeControlsBtn) {
                    closeControlsBtn.addEventListener('click', function() {
                        controlsOverlay.style.display = 'none';
                    });
                }
            }
        });

        // EMERGENCY DIRECT FIGHT BUTTON HANDLER
        document.getElementById('fight-btn').onclick = function() {
            console.error("üî¥ EMERGENCY DIRECT FIGHT BUTTON HANDLER");
            
            // Force character selection if none
            if (!window.p1Character) window.p1Character = 'ninja';
            if (!window.p2Character) window.p2Character = 'samurai';
            
            // Hide all screens
            document.querySelectorAll('.screen').forEach(s => {
                s.style.display = 'none';
                s.classList.remove('active');
            });
            
            // Show battle screen
            const battleScreen = document.getElementById('battle-screen');
            battleScreen.style.display = 'flex';
            battleScreen.classList.add('active');
            console.error("Battle screen forcibly displayed");
            
            // Initialize canvas
            const canvas = document.getElementById('game-canvas');
            canvas.width = 800;
            canvas.height = 450;
            canvas.style.border = '3px solid red';
            canvas.style.background = 'black';
            canvas.style.display = 'block';
            
            // Draw something to show canvas is working
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'green';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create text showing canvas is working
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CANVAS IS WORKING', canvas.width/2, canvas.height/2 - 50);
            ctx.fillText('Game should start shortly...', canvas.width/2, canvas.height/2);
            
            // Try to start game
            setTimeout(function() {
                try {
                    console.error("Attempting to initialize game directly");
                    if (typeof window.initGame === 'function') {
                        console.error("Window.initGame function found!");
                        const game = window.initGame();
                        if (game) {
                            game.setPlayers(window.p1Character || 'ninja', window.p2Character || 'samurai');
                            game.start();
                            console.error("Game started via emergency handler");
                            
                            // Add direct message on screen
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            ctx.fillRect(0, 0, canvas.width, 50);
                            ctx.fillStyle = 'white';
                            ctx.fillText('Game successfully started! Fight!', canvas.width/2, 30);
                        } else {
                            console.error("Game initialization failed");
                            ctx.fillStyle = 'red';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'white';
                            ctx.fillText('ERROR: Game init failed', canvas.width/2, canvas.height/2);
                            ctx.fillText('Press F2 to try character creation', canvas.width/2, canvas.height/2 + 40);
                            ctx.fillText('Press F3 to test canvas', canvas.width/2, canvas.height/2 + 80);
                        }
                    } else {
                        console.error("initGame function not found");
                        ctx.fillStyle = 'red';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'white';
                        ctx.fillText('ERROR: initGame function not found', canvas.width/2, canvas.height/2);
                        
                        // List all available functions in window
                        let availableFunctions = [];
                        for (let prop in window) {
                            if (typeof window[prop] === 'function') {
                                availableFunctions.push(prop);
                            }
                        }
                        console.error("Available window functions:", availableFunctions.join(', '));
                        
                        // Check if main.js was actually loaded
                        const scripts = document.querySelectorAll('script');
                        let mainJsLoaded = false;
                        scripts.forEach(script => {
                            if (script.src && script.src.includes('main.js')) {
                                mainJsLoaded = script.complete;
                                console.error("main.js load status:", mainJsLoaded ? "LOADED" : "FAILED");
                            }
                        });
                        
                        ctx.fillText('Try refreshing the page', canvas.width/2, canvas.height/2 + 40);
                        ctx.fillText('Check browser console for detailed errors', canvas.width/2, canvas.height/2 + 80);
                    }
                } catch (e) {
                    console.error("CRITICAL ERROR:", e);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillText('CRITICAL ERROR: ' + e.message, canvas.width/2, canvas.height/2);
                    ctx.fillText(e.stack.split('\n')[1] || '', canvas.width/2, canvas.height/2 + 40);
                }
            }, 500);
            
            return false;
        };

        // Last chance emergency fixes if something goes wrong
        window.addEventListener('keydown', function(e) {
            // Press F1 key for emergency game reset
            if (e.key === 'F1') {
                console.error("üÜò EMERGENCY KEY ACTIVATED: F1 - Game Reset");
                resetGameEmergency();
            }
            
            // Press F2 key for emergency character creation
            if (e.key === 'F2') {
                console.error("üÜò EMERGENCY KEY ACTIVATED: F2 - Force Character Creation");
                
                // Create a simple visible Character class if it doesn't exist
                if (typeof Character !== 'function') {
                    console.error("Creating emergency Character class");
                    
                    window.Character = function(options) {
                        this.name = options.name || 'unknown';
                        this.x = options.x || 0;
                        this.y = options.y || 0;
                        this.width = options.width || 80;
                        this.height = options.height || 150;
                        this.facingRight = options.facingRight !== false;
                        this.health = options.health || 100;
                        this.maxHealth = options.maxHealth || 100;
                        this.color = options.color || '#' + Math.floor(Math.random()*16777215).toString(16);
                        
                        console.error(`Created emergency Character: ${this.name}`);
                    };
                    
                    // Add required methods
                    Character.prototype.update = function() { return true; };
                    Character.prototype.draw = function(ctx) {
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                        ctx.fillStyle = 'white';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.name, this.x, this.y - this.height - 10);
                        return true;
                    };
                    Character.prototype.takeDamage = function() { return false; };
                    
                    alert("Emergency Character class created. Try fighting again!");
                }
                
                // Force game initialization
                try {
                    if (typeof window.initGame === 'function') {
                        console.error("Using window.initGame function");
                        window.game = window.initGame();
                        
                        if (window.game) {
                            // Show battle screen
                            document.querySelectorAll('.screen').forEach(s => {
                                s.style.display = 'none';
                                s.classList.remove('active');
                            });
                            
                            const battleScreen = document.getElementById('battle-screen');
                            if (battleScreen) {
                                battleScreen.style.display = 'flex';
                                battleScreen.classList.add('active');
                            }
                            
                            // Set players
                            window.game.setPlayers('ninja', 'samurai');
                            window.game.start();
                            
                            alert("Emergency game initialization complete!");
                        } else {
                            // Try one last direct approach
                            console.error("Game initialization failed. Trying direct FightGame creation");
                            
                            const canvas = document.getElementById('game-canvas');
                            if (canvas && typeof FightGame === 'function') {
                                window.game = new FightGame(canvas, true);
                                
                                // Show battle screen
                                document.querySelectorAll('.screen').forEach(s => {
                                    s.style.display = 'none';
                                    s.classList.remove('active');
                                });
                                
                                const battleScreen = document.getElementById('battle-screen');
                                if (battleScreen) {
                                    battleScreen.style.display = 'flex';
                                    battleScreen.classList.add('active');
                                }
                                
                                // Connect UI elements manually
                                window.game.connect({
                                    healthP1: document.getElementById('p1-health'),
                                    healthP2: document.getElementById('p2-health'),
                                    timer: document.querySelector('.timer'),
                                    announcement: document.getElementById('round-announcement'),
                                    roundText: document.getElementById('round-text'),
                                    fightText: document.getElementById('fight-text')
                                });
                                
                                // Set players and start
                                window.game.setPlayers('ninja', 'samurai');
                                window.game.start();
                                
                                alert("Direct game initialization successful!");
                            } else {
                                alert("Critical error: Cannot initialize game!");
                            }
                        }
                    } else {
                        console.error("window.initGame function not available. Trying direct FightGame creation");
                        
                        // Try direct approach anyway
                        const canvas = document.getElementById('game-canvas');
                        if (canvas && typeof FightGame === 'function') {
                            window.game = new FightGame(canvas, true);
                            
                            // Show battle screen
                            document.querySelectorAll('.screen').forEach(s => {
                                s.style.display = 'none';
                                s.classList.remove('active');
                            });
                            
                            const battleScreen = document.getElementById('battle-screen');
                            if (battleScreen) {
                                battleScreen.style.display = 'flex';
                                battleScreen.classList.add('active');
                            }
                            
                            // Connect UI elements manually
                            if (typeof window.game.connect === 'function') {
                                window.game.connect({
                                    healthP1: document.getElementById('p1-health'),
                                    healthP2: document.getElementById('p2-health'),
                                    timer: document.querySelector('.timer'),
                                    announcement: document.getElementById('round-announcement'),
                                    roundText: document.getElementById('round-text'),
                                    fightText: document.getElementById('fight-text')
                                });
                            }
                            
                            // Set players and start
                            window.game.setPlayers('ninja', 'samurai');
                            window.game.start();
                            
                            alert("Direct game initialization successful!");
                        } else {
                            alert("Critical error: FightGame class not available!");
                        }
                    }
                } catch (e) {
                    console.error("Error during emergency initialization:", e);
                    alert("Emergency initialization failed: " + e.message);
                }
            }
            
            // Press F3 key to force a test draw on canvas
            if (e.key === 'F3') {
                console.error("üÜò EMERGENCY KEY ACTIVATED: F3 - Canvas Test");
                
                // Get canvas and test drawing
                const canvas = document.getElementById('game-canvas');
                if (canvas) {
                    try {
                        const ctx = canvas.getContext('2d');
                        
                        // Clear canvas
                        ctx.fillStyle = 'black';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw test pattern
                        ctx.fillStyle = 'red';
                        ctx.fillRect(100, 100, 200, 200);
                        ctx.fillStyle = 'green';
                        ctx.fillRect(300, 100, 200, 200);
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(500, 100, 200, 200);
                        
                        // Draw text
                        ctx.fillStyle = 'white';
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('CANVAS TEST SUCCESSFUL', canvas.width/2, 50);
                        ctx.fillText('Press F2 to create characters', canvas.width/2, 350);
                        
                        alert("Canvas test complete - check if colors are visible");
                    } catch (e) {
                        console.error("Canvas test failed:", e);
                        alert("Canvas test failed: " + e.message);
                    }
                } else {
                    alert("Canvas element not found!");
                }
            }
        });
    </script>
</body>
</html> 